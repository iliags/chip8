use crate::{
    audio::AudioDevice, cpu::CPU, display::Display, keypad::Keypad, memory::Memory,
    message::DeviceMessage, quirks::Quirks,
};

/// Chip-8 Device
#[derive(Debug, Default)]
pub struct C8 {
    /// The RAM (4kb)
    memory: Memory,

    /// The display of the device (64x32)
    display: Display,

    /// Chip-8 CPU
    cpu: CPU,

    /// Stack memory
    stack: Vec<u16>,

    /// Whether the device is running
    is_running: bool,

    /// Keyboard state
    keypad: Keypad,

    /// Quirks
    quirks: Quirks,

    /// Audio device for both web and non-web targets
    pub audio_device: AudioDevice,
}

impl C8 {
    /// Get the memory of the device
    #[must_use] 
    pub fn memory(&self) -> &Memory {
        &self.memory
    }

    /// Get the memory of the device (mutable)
    pub fn memory_mut(&mut self) -> &mut Memory {
        &mut self.memory
    }

    /// Get the quirks of the device
    #[must_use] 
    pub fn quirks(&self) -> &Quirks {
        &self.quirks
    }

    /// Set the quirks of the device
    pub fn set_quirks(&mut self, quirks: Quirks) {
        self.quirks = quirks;
    }

    /// Get the display of the device
    #[must_use] 
    pub fn display(&self) -> &Display {
        &self.display
    }

    /// Get the display of the device (mutable)
    pub fn display_mut(&mut self) -> &mut Display {
        &mut self.display
    }

    /// Get the keypad of the device
    #[must_use] 
    pub fn keypad(&self) -> &Keypad {
        &self.keypad
    }

    /// Get the keypad of the device (mutable)
    pub fn keypad_mut(&mut self) -> &mut Keypad {
        &mut self.keypad
    }

    /// Get if the device is running
    #[must_use] 
    pub fn is_running(&self) -> bool {
        self.is_running
    }

    /// Resets the device, loads ROM and font data into memory, and starts the device
    pub fn load_rom(&mut self, rom: &[u8]) {
        self.reset_device();

        self.memory.load_rom(rom);

        self.is_running = true;
    }

    /// Resets the device
    pub fn reset_device(&mut self) {
        self.audio_device.stop();
        let current_font = self.memory.system_font;
        *self = Self::default();

        // Reload font data
        self.memory
            .load_font_name(current_font, &crate::fonts::FontSize::Small);
    }

    /// Step the device
    pub fn step(&mut self, cpu_speed: u32) -> Vec<DeviceMessage> {
        let mut messages: Vec<DeviceMessage> = Vec::new();

        if self.is_running {
            // TODO: Move timers to CPU with events

            // Update timers
            if self.cpu.delay_timer > 0 {
                self.cpu.delay_timer = self.cpu.delay_timer.saturating_sub(1);
            }

            if self.cpu.sound_timer > 0 {
                self.cpu.sound_timer = self.cpu.sound_timer.saturating_sub(1);

                if self.audio_device.audio_settings().is_enabled() {
                    if self.cpu.audio_buffer().is_empty() {
                        self.audio_device.play_beep();
                    } else if self.cpu.sound_dirty() {
                        self.cpu.clear_sound_dirty();
                        self.audio_device
                            .play_buffer(self.cpu.audio_buffer().clone(), self.cpu.buffer_pitch());
                    }
                }
            } else {
                // TODO: Make this more ergonomic (i.e. only pause if it's playing)
                self.cpu.clear_audio_buffer();
                self.audio_device.pause();
            }

            // Execute instructions
            for _ in 0..cpu_speed {
                let new_message = self.cpu.step(
                    &mut self.memory,
                    &mut self.display,
                    &mut self.stack,
                    &self.quirks,
                    &self.keypad,
                );

                if self.cpu.is_requesting_exit() {
                    self.is_running = false;
                    self.reset_device();
                }

                // Collect messages that the device has
                if let Some(message) = new_message {
                    messages.push(message);
                }
            }
        }

        messages
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Note: These tests were generated by GitHub Copilot

    #[test]
    fn test_load_rom() {
        let mut c8 = C8::default();
        c8.load_rom(&[0x00, 0xE0, 0x00, 0xEE]);
        assert_eq!(c8.memory.data[0x200], 0x00);
        assert_eq!(c8.memory.data[0x201], 0xE0);
        assert_eq!(c8.memory.data[0x202], 0x00);
        assert_eq!(c8.memory.data[0x203], 0xEE);
    }

    #[test]
    fn test_reset_device() {
        let mut c8 = C8::default();
        c8.memory.data[0x200] = 0x01;
        c8.memory.data[0x201] = 0x02;
        c8.memory.data[0x202] = 0x03;
        c8.memory.data[0x203] = 0x04;
        c8.reset_device();
        assert_eq!(c8.memory.data[0x200], 0x00);
        assert_eq!(c8.memory.data[0x201], 0x00);
        assert_eq!(c8.memory.data[0x202], 0x00);
        assert_eq!(c8.memory.data[0x203], 0x00);
    }

    #[test]
    fn test_step_timers() {
        let mut c8 = C8::default();
        c8.load_rom(&[0x00, 0xE0, 0x00, 0xEE]);
        c8.cpu.delay_timer = 1;
        c8.cpu.sound_timer = 1;
        c8.step(1);
        assert_eq!(c8.cpu.delay_timer, 0);
        assert_eq!(c8.cpu.sound_timer, 0);
    }
}
